import React, { useEffect, useState, useRef, useContext, memo, useMemo } from 'react';
import {figures, colors, levelRules} from 'services/config';
import _ from 'lodash';
import Grid from './components/grid'

import { random, createGrid, eachGrid, someForGrid, forRange, createLine } from 'services/utils';
import 'css/global.css';

const GamePlay = ({statisticsRef}) => {
    const emptyCell = {
        color: undefined,
        isActive: false,
        isLanded: false,
        isLandingPlace: false
    }
    const [grid, setGrid] = useState(() => createGrid(emptyCell));
    const activeTetro = useRef(undefined);
    const nextTetro = useRef(undefined);
    const indexColor = useRef(0);
    const idInterval = useRef(undefined);
    

    const getRandomColor = () => {
        const color = colors[indexColor.current];

        indexColor.current += 1;
        if (indexColor.current >= colors.length) {
            indexColor.current = 0;
        }
        return color;
    }

    const createTetro = () => {
        const tetro = figures[random(figures.length)];
        const color = getRandomColor();

        tetro.x = Math.floor((10 - tetro.shape[0].length) / 2);
        tetro.y = -1;
        tetro.color = color;
        return tetro;
    }

    const removeTetro = () => {
        eachGrid(grid, (value, x, y) => {
            if (value.isActive || value.isLandingPlace) {
                grid[y][x] = {
                    color: undefined,
                    isActive: false,
                    isLanded: false,
                    isLandingPlace: false
                }
            }
        })
    }

    const isCollisions = (tetro) => {
        return someForGrid(tetro.shape, (value, x, y) => {
            if (value === 0) {
                return false;
            }
            if (tetro.x + x >= 10 || tetro.x + x < 0 ||
                tetro.y + y >= 20) {
                return true;
            }
            if (grid[tetro.y + y][tetro.x + x].isLanded) {
                return true;
            }
            return false;
        })
    }

    const addTetroInGrid = (tetro) => {
        eachGrid(tetro.shape, (value, x, y) => {
            if (value === 0) {
                return;
            }
            const tetroInLandingPlace = {...tetro};
            forRange(20 - tetroInLandingPlace.y, () => {
                tetroInLandingPlace.y += 1;
                if (isCollisions(tetroInLandingPlace)) {
                    tetroInLandingPlace.y -= 1;
                }
            });
            grid[y + tetroInLandingPlace.y][x + tetroInLandingPlace.x] = {
                color: tetroInLandingPlace.color,
                isActive: false,
                isLanded: false,
                isLandingPlace: true
            };
            grid[y + tetro.y][x + tetro.x] = {
                color: tetro.color,
                isActive: true,
                isLanded: false,
                isLandingPlace: false
            };
        })
    }

    const isLanded = (tetro) => {
        if (!tetro) {
            return false;
        }
        return someForGrid(tetro.shape, (value, x, y) => {
            if (value === 0) {
                return false;
            }
            if (tetro.y + y + 1 >= 20) {
                return true;
            }
            if (tetro.shape[y + 1] !== 1 &&
                grid[tetro.y + y + 1][tetro.x + x].isLanded) {
                return true;
            }
            return false;
        })
    }

    const glueTetro = (tetro) => {
        eachGrid(tetro.shape, (value, x, y) => {
            if (value === 0) {
                return ;
            }
            grid[tetro.y + y][tetro.x + x].isLanded = true;
            grid[tetro.y + y][tetro.x + x].isActive = false;
            grid[tetro.y + y][tetro.x + x].color = tetro.color;
        })
    }

    const deleteLines = () => {
        let isFilledLine = true;
        let countLine = 0;

        eachGrid(grid, (value, x, y) => {
            if (!value.isLanded) {
                isFilledLine = false;
            }
            if (x === 9 && isFilledLine) {
                grid.splice(y, 1);
                grid.splice(0, 0, createLine(emptyCell));
                countLine += 1;
            }
            if (x === 9) {
                isFilledLine = true;
            }
        });
        return countLine;
    }

    const editTetro = (callbackEdit) => {
        const prevTetro = {...activeTetro.current};
        removeTetro();
        callbackEdit();
        if (isCollisions(activeTetro.current)) {
            activeTetro.current = prevTetro;
            return ;
        }
        addTetroInGrid(activeTetro.current)
        setGrid([...grid]);
    }

    const rotateTetro = (tetro) => {
        tetro.shape = tetro.shape[0].map((value, index) => {
            return tetro.shape.map((row) => row[index]).reverse();
        });
    }

    const landedTetro = (tetro) => {
        forRange(20 - tetro.y, () => {
            tetro.y += 1;
            if (isCollisions(tetro)) {
                tetro.y -= 1;
            }
        });
    }

    const handleClick = (event) => {
        switch (event.code) {
            case 'ArrowLeft':
                editTetro(() => activeTetro.current.x -= 1);
                break;
            case 'ArrowUp':
                editTetro(() => rotateTetro(activeTetro.current));
                break;
            case 'ArrowRight':
                editTetro(() => activeTetro.current.x += 1);
                break;
            case 'ArrowDown':
                editTetro(() => activeTetro.current.y += 2);
                break;
            case 'Space':
                editTetro(() => landedTetro(activeTetro.current));
                break;
        }
    }

    const editStatistics = (countDeleteLines) => {
        const [statistics, setStatistics] = statisticsRef.current;

        statistics.lines += countDeleteLines;
        switch (countDeleteLines) {
            case 1:
                statistics.score += levelRules[statistics.level].scorePerLine;
                break;
            case 2:
                statistics.score += levelRules[statistics.level].scorePerLine * 3;
                break;
            case 3:
                statistics.score += levelRules[statistics.level].scorePerLine * 6;
                break;
            case 4:
                statistics.score += levelRules[statistics.level].scorePerLine * 12;
                break;
        }
        if (statistics.score >= levelRules[statistics.level].nextlevelRulescore) {
            statistics.level += 1;
            statistics.speed = levelRules[statistics.level].speed;
            clearInterval(idInterval.current);
            idInterval.current = gameCycle();
        }
        setStatistics({...statistics});
    }

    useEffect(() => {
        document.addEventListener('keydown', handleClick);
        return () => document.removeEventListener('keydown', handleClick)
    });

    const gameCycle = () =>  {
        if (!activeTetro.current) {
            return;
        }
        const level = statisticsRef.current ?
                        statisticsRef.current[0].level :
                        1;

        return setInterval(() => editTetro(() => {
            if (isLanded(activeTetro.current)) {
                glueTetro(activeTetro.current);
                activeTetro.current = {...nextTetro.current};
                nextTetro.current = createTetro();
                const countDeleteLines = deleteLines();
                editStatistics(countDeleteLines);
            }
            activeTetro.current.y += 1;
        }), levelRules[level].speed);
    }

    useEffect(() => {
        activeTetro.current = createTetro();
        nextTetro.current = createTetro();
        idInterval.current = gameCycle();
    }, []);

    return (<Grid grid={grid} isListGridsPlayers={false} nextTetro={nextTetro.current}/>);
}

export default GamePlay;
